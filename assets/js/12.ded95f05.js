(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{372:function(t,a,v){"use strict";v.r(a);var e=v(25),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"html"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[t._v("#")]),t._v(" html")]),t._v(" "),v("h3",{attrs:{id:"meta标签"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#meta标签"}},[t._v("#")]),t._v(" meta标签")]),t._v(" "),v("p",[t._v("元数据（Metadata）是数据的数据信息。")]),t._v(" "),v("p",[v("code",[t._v("<meta>")]),t._v("标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。")]),t._v(" "),v("p",[v("code",[t._v("<meta>")]),t._v("标签永远位于 head 元素内部。")]),t._v(" "),v("p",[v("code",[t._v('<meta name="keywords" content="HTML,ASP,PHP,SQL">')])]),t._v(" "),v("p",[t._v("META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。")]),t._v(" "),v("p",[t._v("元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。")]),t._v(" "),v("h3",{attrs:{id:"html5新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html5新特性"}},[t._v("#")]),t._v(" HTML5新特性")]),t._v(" "),v("ul",[v("li",[t._v("Web Storage")]),t._v(" "),v("li",[t._v("拖放API")]),t._v(" "),v("li",[t._v("WebSocket")]),t._v(" "),v("li",[t._v("地理定位")]),t._v(" "),v("li",[t._v("Canvas绘图")]),t._v(" "),v("li",[t._v("视频和音频"),v("code",[t._v("<audio>")]),t._v("和"),v("code",[t._v("<video>")])])]),t._v(" "),v("h3",{attrs:{id:"语义化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#语义化"}},[t._v("#")]),t._v(" 语义化")]),t._v(" "),v("p",[t._v("怎么知道自己的页面结构是否语义化，那就要看你的HTML结构，在去掉CSS样式表之后，是否，依然能很好的呈现内容的结构，代码结构。也就是说，脱掉css的外衣，依然头是头，脚是脚。赤裸裸的完整的一篇文档。这也就是，语义化之后文档的效果。")]),t._v(" "),v("h3",{attrs:{id:"script-标签会阻塞加载吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#script-标签会阻塞加载吗"}},[t._v("#")]),t._v(" "),v("code",[t._v("<script>")]),t._v("标签会阻塞加载吗")]),t._v(" "),v("p",[t._v("会\n"),v("code",[t._v("<scritp>")]),t._v("标签每次出现，都会让页面等待脚本的解析和执行，无论当前的 JavaScript 代码是内嵌的还是包含在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。")])])}),[],!1,null,null,null);a.default=_.exports}}]);