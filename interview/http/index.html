<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | SummerGua</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" type="image/png" href="https://s3.ax1x.com/2021/01/21/shTlO1.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.1e527139.css" as="style"><link rel="preload" href="/assets/js/app.824bb761.js" as="script"><link rel="preload" href="/assets/js/2.f42e2264.js" as="script"><link rel="preload" href="/assets/js/7.1ced6161.js" as="script"><link rel="prefetch" href="/assets/js/10.65223740.js"><link rel="prefetch" href="/assets/js/11.9b06b4bb.js"><link rel="prefetch" href="/assets/js/12.ded95f05.js"><link rel="prefetch" href="/assets/js/13.98e4a8fa.js"><link rel="prefetch" href="/assets/js/14.d6ec0ece.js"><link rel="prefetch" href="/assets/js/15.90425df1.js"><link rel="prefetch" href="/assets/js/16.d1120b6a.js"><link rel="prefetch" href="/assets/js/17.304ac912.js"><link rel="prefetch" href="/assets/js/18.205fe488.js"><link rel="prefetch" href="/assets/js/19.d80ed4a7.js"><link rel="prefetch" href="/assets/js/20.a4f55c4a.js"><link rel="prefetch" href="/assets/js/21.61120817.js"><link rel="prefetch" href="/assets/js/22.26f87ee5.js"><link rel="prefetch" href="/assets/js/23.439f51ca.js"><link rel="prefetch" href="/assets/js/3.4e0cecce.js"><link rel="prefetch" href="/assets/js/4.cbb17d95.js"><link rel="prefetch" href="/assets/js/5.76adee42.js"><link rel="prefetch" href="/assets/js/6.95086f74.js"><link rel="prefetch" href="/assets/js/8.eb057c4d.js"><link rel="prefetch" href="/assets/js/9.ba7e700a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1e527139.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">SummerGua</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/myinfo/" class="nav-link">
  AboutMe
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/myinfo/" class="nav-link">
  AboutMe
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/interview/" class="sidebar-heading clickable router-link-active open"><span>面经</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/JS/" class="sidebar-link">JS</a></li><li><a href="/interview/HTML/" class="sidebar-link">html</a></li><li><a href="/interview/explorer/" class="sidebar-link">浏览器</a></li><li><a href="/interview/css/" class="sidebar-link">CSS</a></li><li><a href="/interview/http/" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/http/#计算机网络" class="sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/http/#三次握手-四次挥手" class="sidebar-link">三次握手&amp;四次挥手</a></li><li class="sidebar-sub-header"><a href="/interview/http/#get和post的区别" class="sidebar-link">get和post的区别</a></li><li class="sidebar-sub-header"><a href="/interview/http/#url从输入到页面渲染的过程" class="sidebar-link">url从输入到页面渲染的过程</a></li><li class="sidebar-sub-header"><a href="/interview/http/#dns查询" class="sidebar-link">DNS查询</a></li><li class="sidebar-sub-header"><a href="/interview/http/#常见的网络攻击" class="sidebar-link">常见的网络攻击</a></li><li class="sidebar-sub-header"><a href="/interview/http/#介绍一下cookie" class="sidebar-link">介绍一下cookie</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http-only" class="sidebar-link">HTTP-ONLY</a></li><li class="sidebar-sub-header"><a href="/interview/http/#跨域" class="sidebar-link">跨域</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http状态码" class="sidebar-link">HTTP状态码</a></li><li class="sidebar-sub-header"><a href="/interview/http/#https与http区别" class="sidebar-link">https与http区别</a></li><li class="sidebar-sub-header"><a href="/interview/http/#https工作原理" class="sidebar-link">HTTPS工作原理</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http缓存及其原理" class="sidebar-link">http缓存及其原理</a></li><li class="sidebar-sub-header"><a href="/interview/http/#请求头有哪些" class="sidebar-link">请求头有哪些</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http请求的类型有哪些" class="sidebar-link">HTTP请求的类型有哪些？</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http报文组成部分" class="sidebar-link">HTTP报文组成部分</a></li><li class="sidebar-sub-header"><a href="/interview/http/#http2-o和1-x的区别" class="sidebar-link">HTTP2.O和1.x的区别</a></li><li class="sidebar-sub-header"><a href="/interview/http/#etag" class="sidebar-link">ETAG</a></li><li class="sidebar-sub-header"><a href="/interview/http/#tcp滑动窗口和拥塞控制" class="sidebar-link">TCP滑动窗口和拥塞控制</a></li></ul></li></ul></li><li><a href="/interview/project/" class="sidebar-link">项目</a></li><li><a href="/interview/suanfa/" class="sidebar-link">算法</a></li><li><a href="/interview/vue/" class="sidebar-link">vue</a></li><li><a href="/interview/write/" class="sidebar-link">手写系列</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/note/" class="sidebar-heading clickable"><span>工作备忘录</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/oneyear/" class="sidebar-heading clickable"><span>年终总结</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h2> <h3 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="header-anchor">#</a> 三次握手&amp;四次挥手</h3> <p><img src="/assets/img/thirds.58c67980.png" alt="1"></p> <p>ack=上次的syn+1</p> <p><strong>为什么不两次握手</strong></p> <p>若网络拥堵阻塞会有超时重发，服务器收到重发又会建立一次连接</p> <p><strong>为什么不是3次挥手</strong></p> <p>在客服端第1次挥手时，服务端可能还在发送数据。
所以第2次挥手和第3次挥手不能合并。</p> <h3 id="get和post的区别"><a href="#get和post的区别" class="header-anchor">#</a> get和post的区别</h3> <ol><li>get把请求的数据放在url上，即HTTP协议头上，其格式为：
以?分割URL和传输数据，参数之间以&amp;相连。
post把数据放在HTTP的包体内（requrest body）</li> <li>GET产生<strong>一个TCP数据包</strong>，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
POST产生<strong>两个TCP数据包</strong>，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li> <li>get一般用于请求、post一般用于表单提交</li></ol> <h3 id="url从输入到页面渲染的过程"><a href="#url从输入到页面渲染的过程" class="header-anchor">#</a> url从输入到页面渲染的过程</h3> <p>大致：1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理并返回HTTP报文 5.浏览器解析渲染页面</p> <ol><li>构建请求</li> <li>查找缓存资源</li> <li>DNS解析</li> <li>建立TCP连接-三次握手</li> <li>发起HTTP请求
等待服务器返回响应报文，若是<strong>短连接</strong>（HTTP1.0默认），响应后便会四次挥手关闭TCP连接，在下一次连接时重新建立HTTP连接。若是<strong>长连接</strong>（HTTP1.1默认），HTTP发出得到响应后不会关闭TCP，要关闭这个连接，可以通过connection值是否为Keep-Alive来判断，若服务器想明确断开连接的话，将connection的值设为close就可以了</li> <li>协商缓存</li> <li>获取响应</li> <li>渲染
构建DOM树、样式计算、布局（分层、三维计算）、生成图层绘制列表、栅格化操作（图层分为多个图块）、合成与显示</li></ol> <h3 id="dns查询"><a href="#dns查询" class="header-anchor">#</a> DNS查询</h3> <p><strong>递归查询和迭代查询</strong></p> <ol><li>递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。</li> <li>迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</li></ol> <h3 id="常见的网络攻击"><a href="#常见的网络攻击" class="header-anchor">#</a> 常见的网络攻击</h3> <p>常见的网络攻击有：</p> <ol><li>XSS（跨站脚本攻击）
攻击者在WEB页面中插入恶意脚本。当用户浏览页面时，促使脚本执行
<strong>防御方式</strong>：
<ol><li>客户端和服务端对用户输入的数据进行双重验证、</li> <li>对数据进行编码、</li> <li>设置 HTTP Header： “X-XSS-Protection: 1”</li></ol></li> <li>DDOS（分布式拒绝服务）
发送大量请求，导致服务器瘫痪</li> <li>CSRF（跨站请求伪造）
用户本地存储cookie，攻击者利用用户的cookie进行认证，然后伪造用户发出请求<strong>或者HTTP-ONLY</strong> <strong>防御方式</strong>：检查请求头是否同源</li> <li>SQL注入
通过操作输入来修改SQL语句来非法获取数据库中的数据
<strong>防御方式</strong>：对用户输入进行合法校验</li></ol> <h3 id="介绍一下cookie"><a href="#介绍一下cookie" class="header-anchor">#</a> 介绍一下cookie</h3> <p><a href="https://www.cnblogs.com/qcloud1001/p/10101067.html" target="_blank" rel="noopener noreferrer">cookie和webstorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>cookie的编码方式：UrlEncode 十六进制ASCII码每两位加入<code>%</code></p> <h3 id="http-only"><a href="#http-only" class="header-anchor">#</a> HTTP-ONLY</h3> <p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。XSS全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p> <h3 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h3> <h4 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域</h4> <p>浏览器从一个域向另一个域的服务器发送请求来访问其资源。
浏览器的同源策略：协议、域名、端口号一致。</p> <h4 id="解决跨域"><a href="#解决跨域" class="header-anchor">#</a> 解决跨域</h4> <ol><li><p>CORS&quot;跨域资源共享&quot;（Cross-origin resource sharing）
请求的request header中的origin字段和服务器返回的Access-Control-Allow-Origin中的源一致
<strong>使用withCredentials</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://www.abc/api'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//带上了cookie</span>
xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> onLoadHandler<span class="token punctuation">;</span> 
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//设置服务端响应头</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>
</code></pre></div></li> <li><p>反向代理
利用代理服务器接收到请求之后转发给真正的服务器
在vue.config.js中加入proxy写入代理服务器</p></li> <li><p>JSONP（只能实现get）</p> <p>实现跨域请求的原理简单的说，就是动态创建<code>script</code>标签，然后利用<code>script</code>的src 不受同源策略约束来跨域获取数据。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;www.xx.cn?callback=handle&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li></ol> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <ul><li>1xx：信息，服务器收到请求，需要请求者继续执行操作</li> <li>2xx：成功，操作被成功接收并处理</li> <li>3xx：重定向，需要进一步的操作以完成请求</li> <li>4xx：客户端错误</li> <li>5xx：服务器错误</li></ul> <p><strong>常见状态码</strong></p> <p>200：请求成功</p> <p>304：Not Modified 对客户端有缓存情况下服务端的一种响应。客户端在请求时发现自己的缓存文件有修改，那么请求时就会包含If Modified Since，即修改时间，服务器发现该信息说明客户端有缓存，只需判断这个时间和当前请求文件的修改时间就可以确定是返回 304（未修改，客户端直接读取缓存） 还是 200
在进行条件请求时，一般请求头会带上  If-Modified-Since、 If-None-Match，这两个值分别对应响应头 Last-Modified、 ETag 返回的值</p> <p>400：客户端请求的语法错误，服务器无法理解</p> <p>401：请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</p> <p>404：服务器无法根据客户端的请求找到资源</p> <p>500：服务器内部错误</p> <p>502：从远程服务器接收到了一个无效的响应</p> <h3 id="https与http区别"><a href="#https与http区别" class="header-anchor">#</a> https与http区别</h3> <p>URL开头不同，HTTPS端口<strong>443</strong>、HTTP端口<strong>80</strong>，HTTPS需要认证证书SSL</p> <h3 id="https工作原理"><a href="#https工作原理" class="header-anchor">#</a> HTTPS工作原理</h3> <p>对称加密+非对称加密</p> <p>非对称性加密之所以不安全，是应为客户端不知道，这把公钥是不是服务器的。因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。解决这个问题的方式就是使用<strong>数字证书</strong></p> <ol><li>首先服务端给客户端传输证书,这个证书就是公钥,只是包含了很多的信息,比如说证书的办法机构,证书的过期时间</li> <li>客户端进行证书的解析,比如说验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端</li> <li>服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信了</li> <li>服务端将消息进行对称加密(简单来说就是讲消息和私钥进行混合,除非知道私钥否则服务进行解密),私钥正好只有客户端和服务端知道,所以信息就比较安全了</li> <li>服务端将进行对称加密后的消息进行传送</li> <li>客户端使用私钥进行信息的解密</li></ol> <h3 id="http缓存及其原理"><a href="#http缓存及其原理" class="header-anchor">#</a> http缓存及其原理</h3> <p><strong>强缓存</strong>基本原理是：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据。
<strong>协商缓存</strong>主要原理是从缓存数据库中取出缓存的标识，然后向浏览器发送请求验证请求的数据是否已经更新，如果已更新则返回新的数据。</p> <h3 id="请求头有哪些"><a href="#请求头有哪些" class="header-anchor">#</a> 请求头有哪些</h3> <ul><li>accept 请求报头域，指定客户端可以接收的类型有哪些</li> <li>accept-encoding：指定客户端可接收的内容编码</li> <li>accept-language：指定客户端可接收的编码语言</li> <li>host：用户指定请求资源的主机和端口号</li> <li>cookies：用于存储本地的数据</li> <li>refer：用于标识这个请求是从哪个页面来的</li> <li>user-agent:识别用户的使用的客户端版本</li> <li>content-type：用于标识具体请求的媒体类型</li></ul> <h3 id="http请求的类型有哪些"><a href="#http请求的类型有哪些" class="header-anchor">#</a> HTTP请求的类型有哪些？</h3> <p>8种</p> <p><strong>GET、POST</strong> <strong>HEAD</strong>(只返回响应头)
<strong>PUT</strong> <strong>DELETE</strong>(请求服务器删除Request-URI所标识的资源)
<strong>OPTIONS</strong>(测试服务器功能性)
<strong>TRACE</strong>(回显服务器收到的请求，主要用于测试或诊断)
<strong>CONNECT</strong>(让服务器代替用户访问其他网页)</p> <h3 id="http报文组成部分"><a href="#http报文组成部分" class="header-anchor">#</a> HTTP报文组成部分</h3> <p><img src="/assets/img/header.c2309ab2.png" alt="2"></p> <h3 id="http2-o和1-x的区别"><a href="#http2-o和1-x的区别" class="header-anchor">#</a> HTTP2.O和1.x的区别</h3> <ol><li><p>HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示</p></li> <li><p>HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</p></li> <li><p>HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值</p></li> <li><p>HTTP2支持服务器推送
HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容</p></li></ol> <h3 id="etag"><a href="#etag" class="header-anchor">#</a> ETAG</h3> <p><a href="https://www.cnblogs.com/happy4java/p/11206015.html" target="_blank" rel="noopener noreferrer">资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在HTTP1.1规范中，新增了一个HTTP头信息：ETag</p> <p>Etag是 Entity tag的缩写，可以理解为“被请求变量的实体值”</p> <p>客户端在向服务端请求资源的时候，通过If-None-Match请求头带上了之前服务端返回的Etag的值。服务端收到第二次请求的时候，发现携带了If-None-Match字段，就重新计算服务器对应资源的Etag，如果二者匹配了，就认为资源没有发生变化，直接给客户端相应304，让客户端读取缓存中的数据。</p> <h3 id="tcp滑动窗口和拥塞控制"><a href="#tcp滑动窗口和拥塞控制" class="header-anchor">#</a> TCP滑动窗口和拥塞控制</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview/css/" class="prev">
        CSS
      </a></span> <span class="next"><a href="/interview/project/">
        项目
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.824bb761.js" defer></script><script src="/assets/js/2.f42e2264.js" defer></script><script src="/assets/js/7.1ced6161.js" defer></script>
  </body>
</html>
